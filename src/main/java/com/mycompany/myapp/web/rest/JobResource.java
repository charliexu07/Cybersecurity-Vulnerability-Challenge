package com.mycompany.myapp.web.rest;

import com.mycompany.myapp.domain.Job;
import com.mycompany.myapp.repository.JobRepository;
import com.mycompany.myapp.web.rest.errors.BadRequestAlertException;

import io.github.jhipster.web.util.HeaderUtil;
import io.github.jhipster.web.util.ResponseUtil;
import jdk.vm.ci.meta.Local;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.ModelAndView;

import javax.persistence.EntityManager;
import javax.persistence.Query;
import javax.validation.Valid;
import java.net.URI;
import java.net.URISyntaxException;
import java.time.LocalDate;
import java.time.LocalTime;
import java.util.List;
import java.util.Optional;

/**
 * REST controller for managing {@link com.mycompany.myapp.domain.Job}.
 */
@RestController
@RequestMapping("/api")
@Transactional
public class JobResource {

    private final Logger log = LoggerFactory.getLogger(JobResource.class);

    private static final String ENTITY_NAME = "job";

    @Value("${jhipster.clientApp.name}")
    private String applicationName;

    private final JobRepository jobRepository;

    private final EntityManager entityManager;

    public JobResource(JobRepository jobRepository, EntityManager entityManager) {

        this.jobRepository = jobRepository;
        this.entityManager = entityManager;
    }

    /**
     * {@code POST  /jobs} : Create a new job.
     *
     * @param job the job to create.
     * @return the {@link ResponseEntity} with status {@code 201 (Created)} and with body the new job, or with status {@code 400 (Bad Request)} if the job has already an ID.
     * @throws URISyntaxException if the Location URI syntax is incorrect.
     */
    @PostMapping("/jobs")
    public ResponseEntity<Job> createJob(@Valid @RequestBody Job job) throws URISyntaxException {
        log.debug("REST request to save Job : {}", job);
        if (job.getId() != null) {
            throw new BadRequestAlertException("A new job cannot already have an ID", ENTITY_NAME, "idexists");
        }
        Job result = jobRepository.save(job);
        return ResponseEntity.created(new URI("/api/jobs/" + result.getId()))
            .headers(HeaderUtil.createEntityCreationAlert(applicationName, true, ENTITY_NAME, result.getId().toString()))
            .body(result);
    }

    /**
     * {@code PUT  /jobs} : Updates an existing job.
     *
     * @param job the job to update.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the updated job,
     * or with status {@code 400 (Bad Request)} if the job is not valid,
     * or with status {@code 500 (Internal Server Error)} if the job couldn't be updated.
     * @throws URISyntaxException if the Location URI syntax is incorrect.
     */
    @PutMapping("/jobs")
    public ResponseEntity<Job> updateJob(@Valid @RequestBody Job job) throws URISyntaxException {
        log.debug("REST request to update Job : {}", job);
        if (job.getId() == null) {
            throw new BadRequestAlertException("Invalid id", ENTITY_NAME, "idnull");
        }
        Job result = jobRepository.save(job);
        return ResponseEntity.ok()
            .headers(HeaderUtil.createEntityUpdateAlert(applicationName, true, ENTITY_NAME, job.getId().toString()))
            .body(result);
    }

    /**
     * {@code GET  /jobs} : get all the jobs.
     *
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and the list of jobs in body.
     */
    @GetMapping("/jobs")
    public List<Job> getAllJobs() {
        log.debug("REST request to get all Jobs");
        return jobRepository.findAll();
    }

    /**
     * {@code GET  /jobs/:id} : get the "id" job.
     *
     * @param id the id of the job to retrieve.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the job, or with status {@code 404 (Not Found)}.
     */
    @GetMapping("/jobs/{id}")
    public ResponseEntity<Job> getJob(@PathVariable Long id) {
        log.debug("REST request to get Job : {}", id);
        Optional<Job> job = jobRepository.findById(id);
        return ResponseUtil.wrapOrNotFound(job);
    }

    /**
     * {@code DELETE  /jobs/:id} : delete the "id" job.
     *
     * @param id the id of the job to delete.
     * @return the {@link ResponseEntity} with status {@code 204 (NO_CONTENT)}.
     */
    @DeleteMapping("/jobs/{id}")
    public ResponseEntity<Void> deleteJob(@PathVariable Long id) {
        log.debug("REST request to delete Job : {}", id);
        jobRepository.deleteById(id);
        return ResponseEntity.noContent().headers(HeaderUtil.createEntityDeletionAlert(applicationName, true, ENTITY_NAME, id.toString())).build();
    }

    /**
     * {@code GET  /jobs/search_by_position} : get the "position" job.
     *
     * @param position the position of the job to retrieve.
     * @return the {@link String} with status {@code 200 (OK)}
     * This method is highly insecure because it allows SQL Injection to potentially delete a table
     */
    @GetMapping("/jobs/search_by_position")
    public String getJob(@RequestParam String position) {
        //Incorrect Version
        log.debug("REST request to get Job : {}", position);

        List results = entityManager.createNativeQuery("Select * from Job where position ="
            + position, Job.class).getResultList();
        return results.toString();

//        // Correct Version
//        log.debug("REST request to get Job : {}", position);
//
//        if (position.contains(";")) {
//            position = position.substring(0, position.indexOf(";"));
//        }
//
//        List results = entityManager.createNativeQuery("Select * from Job where position ="
//            + position, Job.class).getResultList();
//        return results.toString();
    }

    /**
     * {@code GET  /jobs/add_customized_job} : add a customized job.
     */
    @GetMapping("/jobs/add_customized_job")
    public void addCustomizedJob() {
        Job newJob = new Job();
        LocalDate date = LocalDate.now();
        newJob.setPosition("test");
        newJob.setDescription("test");
        newJob.setDeadline(date);
        jobRepository.save(newJob);
    }

    /**
     * {@code GET  /jobs/deadline_before_date} : get all job applications that have deadlines before given date
     *
     * @param year the year pf given date.
     * @param month the month pf given date.
     * @param day the day pf given date.
     * @return the {@link ModelAndView} with status {@code 200 (OK)}.
     * This method is highly insecure because it allows XSS Injection
     */
    @GetMapping("jobs/deadline_before_date")
    public ModelAndView getJobsBefore(@RequestParam String year, String month, String day) {
        //Incorrect Version
        ModelAndView mv = new ModelAndView("view");

        LocalDate date;
        try {
            date = LocalDate.of(Integer.parseInt(year), Integer.parseInt(month), Integer.parseInt(day));
        }
        catch (Exception e) {
            date = LocalDate.now();
        }

        List<Job> jobs = jobRepository.findAll();

        StringBuilder result = new StringBuilder();

        for(Job j : jobs) {
            if (date.isAfter(j.getDeadline())) {
                result.append(j.toString()).append("\n");
            }
        }

        mv.addObject("year", year);
        mv.addObject("month", month);
        mv.addObject("day", day);

        mv.addObject("jobs", result.toString());

        return mv;

//        // Correct Version
//        ModelAndView mv = new ModelAndView("view");
//
//        LocalDate date;
//        try {
//            date = LocalDate.of(Integer.parseInt(year), Integer.parseInt(month), Integer.parseInt(day));
//        }
//        catch (Exception e) {
//            return mv;
//        }
//
//        List<Job> jobs = jobRepository.findAll();
//
//        StringBuilder result = new StringBuilder();
//
//        for(Job j : jobs) {
//            if (date.isAfter(j.getDeadline())) {
//                result.append(j.toString()).append("\n");
//            }
//        }
//
//        mv.addObject("year", year);
//        mv.addObject("month", month);
//        mv.addObject("day", day);
//
//        mv.addObject("jobs", result.toString());
//
//        return mv;
    }
}
